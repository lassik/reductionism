(import (scheme base) (scheme write))

(define (disp . xs) (for-each display xs) (newline))

(define (edisp . xs)
  (let ((e (current-error-port)))
    (for-each (lambda (x) (display x e)) xs)
    (newline e)
    (flush-output-port e)))

(define (written x)
  (call-with-port (open-output-string)
                  (lambda (out) (write x out) (get-output-string out))))

(define (ascii-alphanumeric? char)
  (let ((cc (char->integer char)))
    (or (<= #x30 cc #x39)
        (<= #x41 cc #x5a)
        (<= #x61 cc #x7a))))

(define (call-with-string-io s thunk)
  (call-with-port
   (open-input-string s)
   (lambda (in)
     (call-with-port (open-output-string)
                     (lambda (out)
                       (parameterize ((current-input-port in)
                                      (current-output-port out))
                         (thunk))
                       (get-output-string out))))))

(define (mangle-word-part sym)
  (string-map (lambda (char)
                (if (ascii-alphanumeric? char)
                    char
                    #\_))
              (symbol->string sym)))

(define (mangle sym)
  (string-append "word_" (mangle-word-part sym)))

(define (mangle-local sym)
  (string-append "local_" (mangle-word-part sym)))

(define dictionary
  (append
   '(
     (<> . "prim_ne")
     (=  . "prim_eq")
     (<  . "prim_lt")
     (<= . "prim_le")
     (>  . "prim_gt")
     (>= . "prim_ge")
     (>=s . "prim_ges")
     (+  . "prim_plus")
     (+s . "prim_pluss")
     (+carry . "prim_plus_carry")
     (-  . "prim_minus")
     (-s . "prim_minuss")
     (*  . "prim_star")
     (*s . "prim_stars")
     (@ . "prim_fetch")
     (! . "prim_store")
     (byte@ . "prim_byte_fetch")
     (byte! . "prim_byte_store")
     )
   (map (lambda (sym)
          (cons sym (string-append "prim_" (mangle-word-part sym))))
        '(drop dup flag cells call allocate reallocate deallocate
               show shows show-hex show-byte show-bytes show-stack zero-cells
               cell-bits max->n-bits n-bits->bitmask and-bits
               os-error-message os-exit os-read os-write))))

(define (read-all)
  (let loop ((xs '()))
    (let ((x (read)))
      (if (eof-object? x) (reverse xs) (loop (cons x xs))))))

(define (lookup-word sym)
  (let ((pair (assoc sym dictionary)))
    (if pair (cdr pair) (error "Undefined word:" sym))))

(define (define-word sym)
  (edisp "Defining: " sym)
  (let ((c-function-name (mangle sym)))
    (set! dictionary (cons (cons sym c-function-name)
                           dictionary))
    c-function-name))

(define ind (make-string 4 #\space))

(define nvariables 0)

(define (handle-variables variables)
  (for-each (lambda (variable)
              (let* ((cell (string-append
                            "cell_" (number->string nvariables)))
                     (fetch (define-word variable))
                     (store (define-word (string->symbol
                                          (string-append
                                           (symbol->string variable)
                                           "!")))))
                (disp)
                (disp "static uintptr_t " cell ";")
                (disp)
                (disp "static void " fetch "(void) {")
                (disp ind "push(" cell ");")
                (disp "}")
                (disp)
                (disp "static void " store "(void) {")
                (disp ind cell " = pop();")
                (disp "}")
                (set! nvariables (+ nvariables 1))))
            variables))

(define (symbol-last sym)
  (let ((str (symbol->string sym)))
    (and (not (= 0 (string-length str)))
         (string-ref str (- (string-length str) 1)))))

(define (symbol-butlast sym)
  (let ((str (symbol->string sym)))
    (string->symbol (substring str 0 (max 0 (- (string-length str) 1))))))

(define (handle-word form)
  (unless (symbol? (car form))
    (error "Malformed word:" form))
  (let ((name (define-word (car form)))
        (body (cdr form))
        (locals '()))
    ;; TODO: Ensure there are no duplicate local variable names.
    (let gather-locals ((tail body) (new-body '()))
      (cond ((null? tail)
             (set! body (reverse new-body)))
            ((and (list? (car tail)) (not (equal? 'quote (caar tail))))
             (set! locals (append locals (car tail)))
             (gather-locals (cdr tail) new-body))
            (else
             (gather-locals (cdr tail) (cons (car tail) new-body)))))
    (disp)
    (disp "static void " name "(void) {")
    (for-each (lambda (local)
                (disp ind "uintptr_t " (mangle-local local) ";"))
              locals)
    (for-each (lambda (part)
                (cond ((equal? '& part)
                       (disp ind "if (!flag) {")
                       (disp ind ind "return;")
                       (disp ind "}"))
                      ((equal? '|| part)
                       (disp ind "if (flag) {")
                       (disp ind ind "return;")
                       (disp ind "}"))
                      ((equal? '|...| part)
                       (disp ind name "();"))
                      ((and (list? part) (equal? 'quote (car part)))
                       (let ((w (lookup-word (cadr part))))
                         (disp ind "pushfunc(" w ");")))
                      ((symbol? part)
                       (cond ((member part locals)
                              (let ((local part))
                                (disp ind "push(" (mangle-local local) ");")))
                             ((and (eqv? #\! (symbol-last part))
                                   (member (symbol-butlast part) locals))
                              (let ((local (symbol-butlast part)))
                                (disp ind (mangle-local local) " = pop();")))
                             (else
                              (disp ind (lookup-word part) "();"))))
                      ((string? part)
                       (disp ind "pushpointer(" (written part) ");")
                       (let ((n (bytevector-length (string->utf8 part))))
                         (disp ind "push(" n ");")))
                      ((exact-integer? part)
                       (if (negative? part)
                           (disp ind "pushsigned(" part ");")
                           (disp ind "push(" part ");")))
                      (else
                       (error "What?" part))))
              body)
    (disp "}")))

(define (main)
  (with-input-from-file "scheme.scm"
    (lambda ()
      (with-output-to-file "scheme.h"
        (lambda ()
          (disp "// Auto-generated")
          (for-each (lambda (form)
                      (unless (and (pair? form) (list? form))
                        (error "Source form is not a proper list:" form))
                      (case (car form)
                        ((variables) (handle-variables (cdr form)))
                        (else (handle-word form))))
                    (read-all)))))))

(main)
